(async () => {
    const authorName =
        prompt("Ù†Ø§Ù… Ù†ÙˆÛŒØ³Ù†Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø¯Ø±Ø¬ Ø¨Ø§Ù„Ø§ÛŒ ÙØ§ÛŒÙ„ Ú†ÛŒØ³ØªØŸ", "")?.trim() || "Ù†Ø§Ù…Ø´Ø®Øµ";

    /* --------------------------------------------------
       1) Ø§Ø³ØªØ®Ø±Ø§Ø¬ ØªØ§Ø±ÛŒØ® Ø«Ø¨Øª ÙÙ‚Ø· Ø§Ø² Ø¬Ø¯ÙˆÙ„ search_writer
    -------------------------------------------------- */
    function pickRegistrationDate(anchor) {
        const row = anchor.closest("tr");
        if (!row) return "";

        const table = row.closest("table");
        if (!table) return "";

        const rows = [...table.querySelectorAll("tr")];

        // Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ø±Ø¯ÛŒÙ Ù‡Ø¯Ø± ÙˆØ§Ù‚Ø¹ÛŒ (Ø§ÙˆÙ„ÛŒÙ† tr Ú©Ù‡ th Ø¯Ø§Ø±Ø¯)
        const headerRow = rows.find(r => r.querySelectorAll("th").length > 0);
        if (!headerRow) return "";

        const headers = [...headerRow.querySelectorAll("th")]
            .map(th => th.textContent.replace(/\s+/g, "").trim());

        // Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ø³ØªÙˆÙ† Â«ØªØ§Ø±ÛŒØ® Ø«Ø¨ØªÂ»
        const dateColIndex = headers.findIndex(h => /ØªØ§Ø±ÛŒØ®Ø«Ø¨Øª/i.test(h));
        if (dateColIndex === -1) return "";

        const cells = [...row.querySelectorAll("td")];
        if (!cells[dateColIndex]) return "";

        return cells[dateColIndex].textContent.trim();
    }

    /* --------------------------------------------------
       2) Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ù„ÛŒÙ†Ú©â€ŒÙ‡Ø§ + ØªØ§Ø±ÛŒØ® Ø«Ø¨Øª (ÙÙ‚Ø· ÛŒÚ©â€ŒØ¨Ø§Ø±)
    -------------------------------------------------- */
    if (!window._patraLinks) {
        const anchors = [
            ...document.querySelectorAll("a[href*='view_search_writer']")
        ];

        const collected = anchors.map(a => ({
            url: a.href,
            registeredAt: pickRegistrationDate(a)
        }));

        const unique = new Map();
        for (const { url, registeredAt } of collected) {
            if (!unique.has(url) || (!unique.get(url) && registeredAt)) {
                unique.set(url, registeredAt || "");
            }
        }

        window._patraLinks = [...unique.entries()].map(
            ([url, registeredAt]) => ({ url, registeredAt })
        );

        console.log("âœ… Ù„ÛŒÙ†Ú©â€ŒÙ‡Ø§ Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø´Ø¯:", window._patraLinks.length);
    } else {
        console.log(
            "â™»ï¸ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù„ÛŒÙ†Ú©â€ŒÙ‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ:",
            window._patraLinks.length
        );
    }

    const links = window._patraLinks;
    if (!links.length) {
        alert("Ù‡ÛŒÚ† Ù„ÛŒÙ†Ú©ÛŒ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯.");
        return;
    }

    /* --------------------------------------------------
       3) Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø±Ú©ÙˆØ±Ø¯ ØªÚ©Ø±Ø§Ø±ÛŒ
    -------------------------------------------------- */
    const seen = window._patraSeen || (window._patraSeen = new Set());

    /* --------------------------------------------------
       4) Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ø·Ù„Ø§Ø¹Ø§Øª ØµÙØ­Ù‡ view_search_writer
    -------------------------------------------------- */
    const concurrency = 10;

    async function extract(link) {
        const { url, registeredAt } = link;

        try {
            const res = await fetch(url, { credentials: "include" });
            const html = await res.text();
            const doc = new DOMParser().parseFromString(html, "text/html");

            const labelMap = new Map();
            const tds = [...doc.querySelectorAll("td")];

            for (let i = 0; i < tds.length - 1; i++) {
                const key = tds[i].textContent.trim();
                if (key && !labelMap.has(key)) {
                    labelMap.set(key, tds[i + 1].textContent.trim());
                }
            }

            const td = label => labelMap.get(label) || "";

            return {
                Ù†Ø§Ù…: td("Ù†Ø§Ù… Ùˆ Ù†Ø§Ù… Ø®Ø§Ù†ÙˆØ§Ø¯Ú¯ÛŒ"),
                "Ø´Ù…Ø§Ø±Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„": td("Ø´Ù…Ø§Ø±Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„"),
                "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ†": td("Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ†"),
                Ø§Ø³ØªØ§Ù†: td("Ø§Ø³ØªØ§Ù†"),
                Ø´Ù‡Ø±: td("Ø´Ù‡Ø±"),
                "Ú©Ø¯ Ø§Ø±Ø³Ø§Ù„": td("Ú©Ø¯ Ø§Ø±Ø³Ø§Ù„"),
                Ø¢Ø¯Ø±Ø³: td("Ø¢Ø¯Ø±Ø³"),
                ØªÙˆØ¶ÛŒØ­Ø§Øª: td("ØªÙˆØ¶ÛŒØ­Ø§Øª"),
                "ØªØ§Ø±ÛŒØ® Ø«Ø¨Øª": registeredAt || "", // ÙÙ‚Ø· Ø§Ø² Ø³Ø±Ú†
                ÙØ±ÙˆØ´Ù†Ø¯Ù‡: td("ÙØ±ÙˆØ´Ù†Ø¯Ù‡")
            };
        } catch (err) {
            console.error("âŒ Ø®Ø·Ø§:", url, err);
            return null;
        }
    }

    async function runWithLimit(items, worker, limit) {
        const results = new Array(items.length);
        let index = 0;

        async function runner() {
            while (index < items.length) {
                const i = index++;
                results[i] = await worker(items[i]);
            }
        }

        await Promise.all(
            Array.from({ length: Math.min(limit, items.length) }, runner)
        );

        return results;
    }

    const raw = await runWithLimit(links, extract, concurrency);
    const clean = raw.filter(Boolean);

    /* --------------------------------------------------
       5) Ø­Ø°Ù ØªÚ©Ø±Ø§Ø±ÛŒâ€ŒÙ‡Ø§ (Ù†Ø§Ù… + Ù…ÙˆØ¨Ø§ÛŒÙ„)
    -------------------------------------------------- */
    const finalRows = [];
    for (const r of clean) {
        const key = (r["Ù†Ø§Ù…"] + r["Ø´Ù…Ø§Ø±Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„"]).replace(/\s+/g, "");
        if (key && !seen.has(key)) {
            seen.add(key);
            finalRows.push(r);
        }
    }

    if (!finalRows.length) {
        alert("Ù‡ÛŒÚ† Ø±Ú©ÙˆØ±Ø¯ Ø¬Ø¯ÛŒØ¯ÛŒ Ø¨Ø§Ù‚ÛŒ Ù†Ù…Ø§Ù†Ø¯.");
        return;
    }

    /* --------------------------------------------------
       6) Ø®Ø±ÙˆØ¬ÛŒ Excel
    -------------------------------------------------- */
    const escapeXml = s =>
        String(s)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&apos;");

    function exportToExcel(rows, filename, author) {
        const headers = Object.keys(rows[0]);

        const xml = `<?xml version="1.0"?>
<?mso-application progid="Excel.Sheet"?>
<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"
 xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet">
<Worksheet ss:Name="Patraplus">
<Table>
<Row>
<Cell ss:MergeAcross="${headers.length - 1}">
<Data ss:Type="String">${escapeXml(author)}</Data>
</Cell>
</Row>
<Row>
${headers
    .map(h => `<Cell><Data ss:Type="String">${escapeXml(h)}</Data></Cell>`)
    .join("")}
</Row>
${rows
    .map(
        r => `<Row>
${headers
    .map(
        h =>
            `<Cell><Data ss:Type="String">${escapeXml(r[h] || "")}</Data></Cell>`
    )
    .join("")}
</Row>`
    )
    .join("")}
</Table>
</Worksheet>
</Workbook>`;

        const blob = new Blob([xml], {
            type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        });

        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = filename + ".xlsx";
        a.click();
    }

    exportToExcel(finalRows, "patraplus_all_unique", authorName);
    console.log("ğŸ‰ ÙØ§ÛŒÙ„ Ø§Ú©Ø³Ù„ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø´Ø¯");
})();
